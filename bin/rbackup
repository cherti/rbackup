#!/usr/bin/env python3

import configparser, sys, os, time, argparse
from rbackup import storer, syncer, lockfile, checkconf, run_cmd, prepare


"""
 preparations
"""


# now parse commandline-args

parser = argparse.ArgumentParser(description='rbackup - rsync-based backuptool')
# choose Backup or Duplicate
parser.add_argument('-b', '--backup', action='store_true', default=False, dest='backup', help='create a new backup')
parser.add_argument('-d', '--duplicate', action='store_true', default=False, dest='dupl', help='duplicate backups to another device')
parser.add_argument('-k', '--checkconf', action='store_true', default=False, dest='chkcfg', help='just check configuration for errors')

parser.add_argument('-s', '--store', action='store_true', default=False, dest='store', help='the run shall be stored and be repeated later in case of disk not becoming available or other problems occur')
parser.add_argument('--no-pending', action='store_true', default=False, dest='nopending', help='stored jobs shall NOT be run beforehand')

parser.add_argument('-t', '--to', action='store', default=None, dest='to', help='targetdisk (via its sectionname)')
parser.add_argument('-f', '--from', action='store', default=None, dest='fro', help='sourcedisk (for duplication; via its sectionname)')
parser.add_argument('-l', '--label', action='store', default=None, dest='label', help='specify label to backup to (for backup)')

parser.add_argument('-c', '--config', action='store', default='/etc/rbackup/rbackup.conf', dest='conffile', help='specify alternative configuration-file')
parser.add_argument('-q', '--quiet', action='store_true', default=False, dest='quiet', help='redirect output to stderr to stdout')
parser.add_argument('-Q', '--Quiet', action='store_true', default=False, dest='Quiet', help='suppress output to stderr entirely')
parser.add_argument('-v', action='count', default=0, dest='verbosity')

args = parser.parse_args(sys.argv[1:])

if args.chkcfg: # just check configuration and exit
	print('checking configuration-file', args.conffile)
	checkconf.checkconfiguration(args.conffile)
	sys.exit(0)

# parse config and check configuration validity
config = checkconf.checkconfiguration(args.conffile)

# make verbosity and cmdline-args in general available in config-dict
config['verbosity'] = args.verbosity
verbosity = args.verbosity
config['args'] = args

# check whether args are such that we can work with them
checkconf.checkargs(args, config=config)

# prepare lockfile
lock = lockfile.Lockfile(config['general']['lockfile'])

if not args.nopending:
	if verbosity > 0: print('doing stored jobs')
	currjob = storer.jobstring(args)
	storer.run_stored(config['general']['pendingfile'], skip_job=currjob, config['verbosity'])


# giving status update what will be done (for user or logs)
if args.backup:
	print('making backup to label {0} on device {1}'.format(args.label, args.to))
elif args.to not in ['labels', 'general']:
	print('duplicating backup from {0} to device {1}'.format(args.fro, args.to))


if args.quiet: # if the user wanted to have a quiet run
	sys.stderr = sys.stdout # everything written to stderr goes to stdout instead
elif args.Quiet:
	sys.stderr = open(os.devnull, 'w') # redirects sys.stderr to /dev/null


#
# everything fine, time to do some magic!
#

# here was def prepade


while lock.isValid(): # wait for other processes of this kind to terminate via block
	time.sleep(30)

# now create lock to let other processes know that we want to do a backup
lock.create()

if args.backup: # we want to create a backup
	pre = config[args.to]['preexec']
	preto = config[args.to]['pretimeout']
	post = config[args.to]['postexec']
	postto = config[args.to]['posttimeout']
	dst = config[args.to]['backupdir']
	src = config['general']['backupsource']

	prepare(pre, preto, dst, config)

	# decide whether we want to sync a entirely new backup or to copy one to a later stage
	labels = config['general']['labelorder']  # get list of labels from config
	if verbosity > 1: print('labels: ' + labels)
	curr_label_index = labels.index(args.label) # get the index of the current label in list


	if curr_label_index == 0: # it's the first label, so sync a new backup
		rsync_ret = syncer.backup_sync(src, dst, args.label, config) # ACTION !!!

		if rsync_ret != 0:
			print('rsync finished with errors: exit code {0}'.format(rsync_ret), file=sys.stderr)

	else: # higher-order label, copy a backup into a later stage
		prev_label = labels[curr_label_index-1] # get the previous label to copy from

		cp_ret = syncer.backup_copy(dst, prev_label, args.label, config) # ACTION !!!

		if cp_ret != 0:
			print('cp finished with errors: exit code {0}'.format(cp_ret), file=sys.stderr)


	# tidy up devices afterwards
	postret = run_cmd(post, postto, verbosity)

	if postret != 0:
		if postret == 32256: # no-permission-error
			print('no permission to execute post-script; is it executable?', file=sys.stderr)

		print('post-script finished with errors: exit code {0}'.format(postret), file=sys.stderr)

else: # duplicate backup to another disk, args.dupl == True

	# get configuration
	srcpre = config[args.fro]['preexec']
	srcpreto = config[args.fro]['pretimeout']
	srcpost = config[args.fro]['postexec']
	srcpostto = config[args.fro]['posttimeout']
	src = config['general']['backupsource']

	dstpre = config[args.to]['preexec']
	dstpreto = config[args.to]['pretimeout']
	dstpost = config[args.to]['postexec']
	dstpostto = config[args.to]['posttimeout']
	dst = config[args.to]['backupdir']

	prepare(srcpre, srcpreto, src, config)
	prepare(dstpre, srcpostto, dst, config)

	rsync_ret = syncer.simple_sync(src, dst, config)

	if rsync_ret != 0:
		print('rsync finished with errors: exit code {0}'.format(rsync_ret), file=sys.stderr)


	# tidy up afterwards

	time.sleep(5)

	postret = run_cmd(srcpost, srcpostto, verbosity)

	if postret != 0:
		if preret == 32256: # no-permission-error
			print('no permission to execute post-script of device {0}; is it executable?'.format(args.fro), file=sys.stderr)

		print('post-script for device {0} finished with errors: exit code {1}'.format(args.fro, postret), file=sys.stderr)

	# tidy up afterwards
	postret = run_cmd(dstpost, dstpostto, verbosity)

	if postret != 0:
		if preret == 32256: # no-permission-error
			print('no permission to execute post-script of device {0}; is it executable?'.format(args.to), file=sys.stderr)

		print('post-script for device {0} finished with errors: exit code {1}'.format(args.to, postret), file=sys.stderr)


lock.remove() # finally release lock when done
